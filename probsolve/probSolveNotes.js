//Problem Solving

    //Understand the problem
        //Can I restate the problem in my own words?
        //What are the inputs?
        //What are the outputs?
        //Can outputs be determined by inputs?
        //How should I label important imortant pieces of informaton

    //Explore Concrete Examples
        //Start with simple examples (with input/output)
        //Progress to more complex examples
        //Explore edge case examples (empty inputs, null, etc)

    //Break It Down
        //Write out the steps you need to take
        //Think about code before coding
        //Pseudo code thought process

    //Solve/Simplify
        //Solve the problem or solve a simpler problem of the same nature
        //Find core difficulty, remove it, and solve a simple version of that problem without core difficulty
        //Then refactor difficulty back in

    //REFACTOR/LOOK BACK
        //Think of BigO, time and space complexity, changes for readability, etc.